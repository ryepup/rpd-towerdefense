(in-package :rpd-towerdefense)

(defvar *renderer* nil)

(defclass renderer ()
  ((board :accessor board :initarg :board)))

(defgeneric %with-renderer (renderer board)
  (:method :around ((self renderer) board)
    (declare (ignore board))
    (let ((*renderer* self))
      (call-next-method))))

(defgeneric render-turn (renderer turn-number))
(defgeneric render-game-piece (renderer piece))
(defgeneric render-plan (renderer piece plan))

(defmacro with-renderer ((&rest renderer-args) board)
  `(%with-renderer
    (make-instance ,@renderer-args)
    ,board))

(defclass sdl-renderer (renderer)
  ((cell-size :reader cell-size :initform 48)
   (width :reader width :initarg :width)
   (height :reader height :initarg :height)
   (surfaces :accessor surfaces :initform nil)
   (animations :accessor animations :initform (make-instance 'cl-heap:priority-queue))))

(defmethod surface ((self sdl-renderer) surface-keyword)
  (cdr (assoc surface-keyword (surfaces self))))
(defmethod add-surface ((self sdl-renderer) surface-keyword surf)
  (push (cons surface-keyword surf) (surfaces self)))

(defmethod render-game-piece ((self sdl-renderer) p)
  (let ((cell-size (cell-size self)))
    (sdl:draw-filled-circle-* (+ (/ cell-size 2) (* cell-size (x p)))
			      (+ (/ cell-size 2) (* cell-size (y p)))
			      (truncate (/ cell-size 3))
			      :color sdl:*white*)))

(defmethod render-game-piece ((self sdl-renderer) (r refinery))
  (let ((cell-size (cell-size self)))
    (sdl:draw-surface-at-* (surface self :sprite)
			   (1+ (* cell-size (x r)))
			   (1+ (* cell-size (y r)))
			   :cell 1)))

(defmethod render-sprite ((self sdl-renderer) cell (p game-piece))
  (let ((cell-size (cell-size self)))
    (sdl:draw-surface-at-* (surface self :sprite)
			   (1+ (* cell-size (x p)))
			   (1+ (* cell-size (y p)))
			   :cell cell)))

(defmethod render-plan ((self sdl-renderer) (r refinery)
			(plan (eql :refine)))
  (iter (for cell in '(2 2 2 3 3 3 2 2 2))
	(for frame from 1)
	(cl-heap:enqueue (animations self)
			 (let ((cell cell))
			   (lambda () (render-sprite self cell r)))
			 frame)))

(defmethod render-plan ((self sdl-renderer) p (plan (eql :idle))))

(defmethod render-turn ((self sdl-renderer) turn-number)
  (sdl:blit-surface (surface self :board))
  (iter (for p in (pieces (board self)))
	(render-game-piece self p))
  (sdl:update-display))

(defmethod draw-board ((self sdl-renderer)
		       &key (square-length (cell-size self))
		       &allow-other-keys) 
  (sdl:with-surface (grid
		     (sdl:create-surface (width self)
					 (height self))
		     nil)
    (sdl:draw-box-* 1 1 (width self) (height self)
		    :color sdl:*black*)
    (sdl:with-color (_ (sdl:color :r 127 :g 127 :b 127))
      (destructuring-bind (board-width board-height)
	  (bounds (board self))	
	(dotimes (x (1+ board-width))
	  (sdl:draw-vline (* x square-length)
			  1 (* board-height square-length))
	  (dotimes (y (1+ board-height))
	    (sdl:draw-hline 1 (* board-width square-length)
			    (* y square-length))))))
    (sdl:set-point-* grid :y 0 :x 0)
    (add-surface self :board grid)
    grid))

(defmethod load-sprites ((self sdl-renderer))
  (let ((sprite (sdl:load-image "/home/ryan/lisp/rpd-towerdefense/assets/Beacon.bmp")))
    (setf (sdl:cells sprite)
	  (iter
	    (for (x y w h) in '((1 3 47 45)
				(1 51 47 45)
				(49 51 47 45)
				(97 51 47 45)))
	    (collect
		(sdl:rectangle :x x :y y :w w :h h))))
    (add-surface self :sprite sprite)))

(defmethod %with-renderer ((self sdl-renderer) board)
  (sdl:with-init ()
    (sdl:window (width self) (height self))
    (setf (sdl:frame-rate) 15)
    (load-sprites self)
    (draw-board self) 
    (sdl:with-events ()
      (:quit-event ()
		   (mapc (compose #'sdl:free #'cdr)
			 (surfaces self))
		   T)
      (:idle ()
	     (when (done-with-animations-p self)
	       (simulate board 1))))))

(defmethod done-with-animations-p ((self sdl-renderer))
  (if-let ((a (cl-heap:dequeue (animations self))))
    (progn
      (funcall a)
      (sdl:update-display)
      nil)
    T))



